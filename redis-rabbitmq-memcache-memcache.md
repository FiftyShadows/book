百度坑爹 自己对比了好多资料问了好多人,做一下简单的对比
####redis
**应用场景:Redis：轻量级，高并发，延迟敏感
即时数据分析、秒杀计数器、缓存等.用在实时的对可靠性要求比较高的消息传递上。**
1. 没有相应的机制保证消息的消费，当消费者消费失败的时候，消息体丢失，需要手动处理
2. 需要自行实现发布
3. 不提供消费负载均衡
4. 不提供队列监控
5. 入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。
6. value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作
7. 当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据
####RabbitMQ
**应用场景:异步处理,流量削峰.任务分发,消息持久化,消息序列化  重量级，高并发，异步
批量数据异步处理、并行任务串行化，高负载任务的负载均衡等**
1. 具有消息消费确认，即使消费者消费失败，也会自动使消息体返回原队列，同时可全程持久化，保证消息体被正确消费,可靠发布，可靠消费
2. 具有发布确认功能，保证消息被发布到服务器
3. 集群采用磁盘、内存节点，任意单点故障都不会影响整个队列的操作
4. 根据消费者情况，进行消息的均衡分发
5. 后台可以监控某个队列的所有信息，（内存，磁盘，消费者，生产者，速率等）
6. 服务器过载的情况，对生产者速率会进行限制，保证服务可靠性
####kafka
#####高性能跨语言分布式发布/订阅消息队列系统
应用场景:实时log分析
1. 快速持久化，可以在O(1)的系统开销下进行消息持久化
2. 高吞吐
3. 完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡
4. 支持Hadoop数据并行加载
5. 分布式，把写入压力均摊到各个节点。可以通过增加节点降低压力
6. 即使消息被消费,消息仍然不会被立即删除.日志文件将会根据broker中的配置要求,保留一定的时间之后删除;比如log文件保留2天,那么两天后,文件会被清除,无论其中的消息是否被消费.kafka通过这种简单的手段,来释放磁盘空间,以及减少消息消费之后对文件内容改动的磁盘IO开支.
7. 动态扩容
####Memcached
###别看这个,似乎被redis碾压!
**是一个高性能的分布式内存对象缓存系统，用于动态 Web 应用以减轻数据库负载压力。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度**
1. 天生支持集群
2. 多核
3. 默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。
4. 也可用于缓存其他东西，例如图片、视频等等；
5. memcache挂掉后，数据不可恢复