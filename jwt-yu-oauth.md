mac测试提交
####Authentication（认证）和Authorization（鉴权）

##首先介绍下jwt

>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。

###基于token的认证和传统的session认证的区别。

###传统的session认证

我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。

但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.

###基于session认证所显露的问题

**Session**: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。

**扩展性**: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。

**CSRF**: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。

###基于token的鉴权机制

基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。

流程上是这样的：

- 用户使用用户名密码来请求服务器
- 服务器进行验证用户的信息
- 服务器通过验证发送给用户一个token
- 客户端存储token，并在每次请求时附送上这个token值
- 服务端验证token值，并返回数据

这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了`Access-Control-Allow-Origin: *`。

###JWT长什么样？

JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样:

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ`

###JWT的构成

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).


####headerjwt的头部承载两部分信息：

- 声明类型，这里是jwt
- 声明加密的算法 通常直接使用 HMAC SHA256
完整的头部就像下面这样的JSON：
```python
{
  'typ': 'JWT',
  'alg': 'HS256'
}
```

然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.

`eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9`

####playload

载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分

- 标准中注册的声明
- 公共的声明
- 私有的声明

#####标准中注册的声明 (建议但不强制使用) ：
- **iss**: jwt签发者                               
- **sub**: jwt所面向的用户                            
- **aud**: 接收jwt的一方                             
- **exp**: jwt的过期时间，这个过期时间必须要大于签发时间             
- **nbf**: 定义在什么时间之前，该jwt都是不可用的.                
- **iat**: jwt的签发时间                             
- **jti**: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。  

#####公共的声明 ：

公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.

#####私有的声明 ：

私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。


定义一个payload:

```python
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

然后将其进行base64加密，得到Jwt的第二部分。

`eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9`


####signature

jwt的第三部分是一个签证信息，这个签证信息由三部分组成：

- header (base64后的)
- payload (base64后的)
- secret

这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。

```javascript
// javascript
var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```
#####注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。

####如何应用
一般是在请求头里加入`Authorization`，并加上`Bearer`标注：
```python
fetch('api/user/1', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
```

服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的:

![](/assets/444444.png)


####总结

####优点

- 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。
- 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。
- 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。
- 它不需要在服务端保存会话信息, 所以它易于应用的扩展

####安全相关

- 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。
- 保护好secret私钥，该私钥非常重要。
- 如果可以，请使用https协议



<br>
<br>


##OAuth 认证流程详解


####首先一定要看下阮一峰的博客:http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

很多网站、APP 弱化甚至没有搭建自己的账号体系，而是直接使用社会化登录的方式，这样不仅免去了用户注册账号的麻烦、还可以获取用户的好友关系来增强自身的社交功能。

比如我们可以使用微博登录简书，简书会自动将你的微博头像设置为你的简书头像，将你的微博昵称设置为你的简书昵称，甚至还可以获取你微博中的好友列表，提示你哪些朋友已经在使用简书，这是如何做到的呢？

最传统的办法是让用户直接在简书的登录页面输微博的账号和密码，简书通过用户的账号和密码去微博那里获取用户数据，但这样做有很多严重的缺点：

- 简书需要明文保存用户的微博账号和密码，这样很不安全。
- 简书拥有了获取用户在微博所有的权限，包括删除好友、给好友发私信、更改密码、注销账号等危险操作。
- 用户只有修改密码，才能收回赋予简书的权限。但是这样做会使得其他所有获得用户授权的第三方应用程序全部失效。
- 只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有使用微博登录的网站的数据泄漏。
为了解决以上的问题，OAuth 协议应运而生。

###原理概要

新浪微博作为服务提供商，拥有用户的头像、昵称、邮箱、好友以及所有的微博内容，简书希望获取用户存储在微博的头像和昵称，假设它们是三个人：

- 简书问新浪微博：我想要获取用户 A 的头像和昵称，请你提供
- 微博说：我需要经过用户Ａ 本人的许可，然后去问用户 A 是否要授权简书访问自己的头像和昵称
- 用户 A 对微博说：我给简书一个临时的钥匙，如果他给你出示了这把钥匙，你就把我的资料给他
- 简书使用户给它的钥匙获取用户头像和昵称信息。

以上是 OAuth 认证的大概流程。在使用微博授权之前，简书需要先在微博开放平台上注册应用，填写自己的名称、logo、用途等信息，微博开放平台颁发给简书一个应用 ID 和叫 APP Secret 的密钥，在实际对接中，会使用到这两个参数。

###详细流程

![](/assets/213.png)

接下来分步详细解释上图中每步都做了什么：

#### 1.用户点击简书上的微博登录按钮，跳转到微博授权页面。微博登录按钮的链接形如下方的 URL：

```python
https://api.weibo.com/oauth2/authorize?client_id=123050457758183&redirect_uri=http://jianshu.com/callback
```

URL 中要包含以下参数：
1. **client_id**：在微博开放平台申请的应用 ID
2. **redirect_uri**：授权成功后要跳转到的地址

点击以上链接后跳转到微博的授权页面如下图：

![](/assets/5555.png)

这个页面会告诉用户第三方应用要获取用户的哪些数据，以及拥有什么权限，比如在上图中简书会要求获得个人信息、好友关系、分享内容到微博以及获得评论的权限，用户点击“允许”则表示允许简书获得这些数据，进行下一步

####2. 页面自动跳转到初始参数中`redirect_uri`定义的那个URL，并自动在 URL 末尾添加一个 `code` 参数，实际跳转的地址形如:

```
http://jianshu.com/callback?code=2559200ecd7ea433f067a2cf67d6ce6c
```

####3. 第三步，简书通过上一步获取的 code 参数换取 Token，Token 就是前文中说到的钥匙。简书请求如下的接口获取 Token：
POST https://api.weibo.com/oauth2/access_token
####要包含以下参数：

- **client_id**：在微博开放平台申请的应用 ID很多语言都可以使用。 
- **client_secret**：在微博开放平台申请时提供的APP Secret 
- **grant_type**：需要填写authorization_code 
- **code**：上一步获得的 code 
- **redirect_uri**：回调地址，需要与注册应用里的回调地址以及第一步的 redirect_uri 参数一致 

####4. 通过第三步的请求，接口返回 Token 和相关数据：

```json
{
"access_token": "ACCESS_TOKEN",//Token 的值
"expires_in": 1234,//过期时间
"uid":"12341234"//当前授权用户的UID。
}
```
####5. 在第四步中获取了access_token ，使用它，就可以去获取用户的资源了，要获取用户昵称和头像，请求如下接口：
####GET https://api.weibo.com/2/users/show.json
携带参数：

- **access_token**：上一步获取的access_token
- **uid**：用户的账号 id，上一步的接口有返回 

####6. 最后一步，微博返回用户信息，简书进行处理，整个流程结束

通过以上的方式，在简书和新浪微博中间建立了一个独立的权限层，这个权限由用户赋予，可以被用户随时取消，不同第三方应用之间相互独立，互不干扰，这样就彻底解决了明文存放账号密码的问题。




