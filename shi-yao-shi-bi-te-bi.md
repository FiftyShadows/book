#来源:廖大大的博客
####非对称加密

你可能听说过这个词，所谓非对称加密，其实很简单，就是加密和解密需要两把钥匙：一把公钥和一把私钥。

公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息，然后发送给你，你用私钥解密，取出信息。反过来，你也可以用私钥加密信息，别人用你的公钥解开，从而证明这个信息确实是你发出的，且未被篡改，这叫做数字签名（更详细的介绍请看《[什么是数字签名](/什么是数字签名)》）。

现在请设想，如果公钥加密的不是普通的信息，而是加密了一笔钱，发送给你，这会怎样？

首先，你能解开加密包，取出里面的钱，因为私钥在你手里。其次，别人偷不走这笔钱，因为他们没有你的私钥。因此，支付可以成功。

这就是比特币（以及其他数字货币）的原理：非对称加密保证了支付的可靠性。

由于支付的钱必须通过私钥取出，所以你是谁并不重要，重要的是谁拥有私钥。只有拥有了私钥，才能取出支付给你的钱。（事实上，真实的交易流程稍有不同，私钥保证的不是取出支付给你的钱，而是保证只有你能把这些属于你的钱支付出去，详见后文。）

####比特币钱包

对于比特币来说，钱不是支付给个人的，而是支付给某一把私钥。这就是交易匿名性的根本原因，因为没有人知道，那些私钥背后的主人是谁。

所以，**比特币交易的第一件事，就是你必须拥有自己的公钥和私钥。**    

你去网上那些比特币交易所开户，它们会让你首先生成一个比特币钱包（wallet）。**这个钱包不是用来存放比特币，而是存放你的公钥和私钥。软件会帮你生成这两把钥匙**，然后放在钱包里面。

根据协议，公钥的长度是512位。这个长度不太方便传播，因此协议又规定，要为公钥生成一个160位的指纹。所谓指纹，就是一个比较短的、易于传播的哈希值。160位是二进制，写成十六进制，大约是26到35个字符，比如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2。这个字符串就叫做钱包的地址，它是唯一的，即每个钱包的地址肯定都是不一样的。

![](/assets/bg2018010405.png)

你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。由于你是这个地址的拥有者，所以你会收到这笔钱。

由于你是否拥有某个钱包地址，是由私钥证明的（具体的证明方法稍后介绍），所以一定要保护好私钥。这是极其重要的，如果你的私钥被偷了，你的比特币也就等于没了，因为他人可以冒用你的身份了，把钱包里面的钱都转走。

同样的，你向他人支付比特币，千万不能写错他人的钱包地址，否则你的比特币就支付到了另一个不同的人了。

####交易过程

下面，我把整个流程串起来，看看比特币如何完成一笔交易。

**一笔交易就是一个地址的比特币，转移到另一个地址。**    由于比特币的交易记录全部都是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否拥有足够的比特币，完成这笔交易，这是可以轻易验证的。

问题出在怎么防止其他人，冒用你的名义申报交易。举例来说，有人申报了一笔交易：地址 A 向地址 B 支付10个比特币。我怎么知道这个申报是真的，申报人就是地址 A 的主人？

比特币协议规定，申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。


- **上一笔交易的 Hash（你从哪里得到这些比特币）**
- **本次交易双方的地址**
- **支付方的公钥**
- **支付方的私钥生成的数字签名**

验证这笔交易是否属实，需要三步。

- **第一步，找到上一笔交易，确认支付方的比特币来源。**
- **第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。**
- **第三步，- **使用公钥去解开数字签名，保证私钥属实。**

####交易确认与区块链

确认交易的真实性以后，交易还不算完成。**交易数据必须写入数据库，才算成立，对方才能真正收到钱。**

比特币使用的是一种特殊的数据库，叫做区块链（blockchain），详细的介绍请看《区块链入门教程》。本文只讨论交易如何写入区块链。

首先，所有的交易数据都会传送到矿工那里。矿工负责把这些交易写入区块链。

根据比特币协议，一个区块的大小最大是 1MB，而一笔交易大概是500字节左右，因此一个区块最多可以包含2000多笔交易。矿工负责把这2000多笔交易打包在一起，组成一个区块，然后计算这个区块的 Hash。

![](/assets/bg2018010406.jpg)

计算 Hash 的过程叫做采矿，这需要大量的计算。矿工之间也在竞争，谁先算出 Hash，谁就能第一个添加新区块进入区块链，从而享受这个区块的全部收益，而其他矿工将一无所获。

一笔交易一旦写入了区块链，就无法反悔了。这里需要建立一个观念：**比特币不存放在钱包或其他别的地方，而是只存在于区块链上面。**区块链记载了你参与的每一笔交易，你得到过多少比特币，你又支付了多少比特币，因此可以算出来你拥有多少资产。


####矿工的收益

交易的确认离不开矿工。为什么有人愿意做矿工呢？

比特币协议规定，挖到新区块的矿工将获得奖励，一开始（2008年）是50个比特币，然后每4年减半，目前（2018年）是12.5个比特币。这也是比特币的供给增加机制，流通中新增的比特币都是这样诞生的。

你可能看出来了，每4年奖励减半，那么到了2140年，矿工将得不到任何奖励，比特币的数量也将停止增加。这时，矿工的收益就完全依靠交易手续费了。

所谓交易手续费，就是矿工可以从每笔交易抽成，具体的金额由支付方自愿决定。你完全可以一毛不拔，一分钱也不给矿工，但是那样的话，你的交易就会没人处理，迟迟无法写入区块链，得到确认。矿工们总是优先处理手续费最高的交易。

目前由于交易数量猛增，手续费已经水涨船高，一个区块2000多笔交易的手续费总额可以达到3～10个比特币。如果你的手续费给低了，很可能过了一个星期，交易还没确认。

一个区块的奖励金12.5个比特币，再加上手续费，收益是相当可观的。按照目前的价格，可以达到100万～200万人民币。想想看，运气好的话，几分钟就能挖到一个区块，拿到这样一大笔钱，怪不得人们对挖矿趋之若鹜。

####本质
说到底，比特币只是区块链的一条记录，是凭空生成的，为什么可以当钱用？举例来说，矿工获得12.5个比特币的奖励，其实就是区块链有一个记录："xxx地址获得12.5个比特币"。正是这行记录，导致该矿工获得了大笔金钱。如果区块链突然增加了一条记录，记载你的地址获得了1000个比特币，你就真的会有1000个比特币。这到底是为什么？


####比特币区块


比特币区块由区块头和该区块所包含的交易列表组成。区块头大小为80字节，其构成包括：
 
　　 4字节：版本号
　　32字节：上一个区块的哈希值
　　32字节：交易列表的Merkle根哈希值
　　 4字节：当前时间戳
　　 4字节：当前难度值
　　 4字节：随机数Nonce值
 
　　此80字节长度的区块头，即为比特币Pow算法的输入字符串。
　　交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。

```java
class CBlockHeader
{
public:
    //版本号
    int32_t nVersion;
    //上一个区块的哈希值
    uint256 hashPrevBlock;
    //交易列表的Merkle根哈希值
    uint256 hashMerkleRoot;
    //当前时间戳
    uint32_t nTime;
    //当前挖矿难度，nBits越小难度越大
    uint32_t nBits;
    //随机数Nonce值
    uint32_t nNonce;
    //其它代码略
};

class CBlock : public CBlockHeader
{
public:
    //交易列表
    std::vector<CTransactionRef> vtx;
    //其它代码略
};
//代码位置src/primitives/block.h
```
####pow 算法原理


Pow的过程，即为不断调整Nonce值，对区块头做双重SHA256哈希运算，使得结果满足给定数量前导0的哈希值的过程。
　　其中前导0的个数，取决于挖矿难度，前导0的个数越多，挖矿难度越大。
 
　　具体如下：
 
　　1、生成铸币交易，并与其它所有准备打包进区块的交易组成交易列表，生成Merkle根哈希值。
　　2、将Merkle根哈希值，与区块头其它字段组成区块头，80字节长度的区块头作为Pow算法的输入。
　　3、不断变更区块头中的随机数Nonce，对变更后的区块头做双重SHA256哈希运算，与当前难度的目标值做比对，如果小于目标难度，即Pow完成。
 
　　Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。之后将进入下一轮挖矿。


####难度更改

每创建2016个块后将计算新的难度，此后的2016个块使用新的难度。计算步骤如下：
 
　　1、找到前2016个块的第一个块，计算生成这2016个块花费的时间。
即最后一个块的时间与第一个块的时间差。时间差不小于3.5天，不大于56天。
　　2、计算前2016个块的难度总和，即单个块的难度x总时间。
　　3、计算新的难度，即2016个块的难度总和/14天的秒数，得到每秒的难度值。
　　4、要求新的难度，难度不低于参数定义的最小难度。